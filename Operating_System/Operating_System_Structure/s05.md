---
title : Operating System Structure-2.5
description : chapter 2.5  of the <Operating System Concepts>
tags : [os, notes, ]
---

# Operating System Structure

---

## 2.5 - Linker and Loader

> When a program is executed, it does not got directly from source code to running. Instead it goes through a pipeline :

> Source code -> compiler -> object file -> linker -> executable -> loader -> running process.

### Linker

A linker combines one or more object files into a single executable file. 

- Symbol resolution : Linker finds the actual memory addresses or locations of external functions and global variables.
- Combining object files : Linker merges compiled code, standard libraries, runtime libraries.
- Relocation : Object files contain relative addresses, not absolute. Linker adjusts address for the final executable code.

**Static Linking** : All needed code is included in the final executable. The file size is larger, and no need for external libraries at runtime.

**Dynamic Linking** : Actual library code (shared library/DLL) is loaded at runtime. The executable file is smaller and libraries are easy to update.

### Loader 

A loader is part of OS responsible for loading executable from disk to memory, preparing it to run, and starting the program.

- Read executable file format : Loader locates code segment, data segment, dynamic linking info, entry point.
- Load segments into memory : Loader maps code to text segment, data to data segment, and sets up stack and heap.
- Relocation (if needed) : For dynamically linked programs, runtime relocations may still be needed.
- Initialize the runtime environment : Loader sets up stack, heap, environment variable, arguments.
- Transfer control to entry point : Finally, the loader jumps to the program's entry point. For example, in C, ```_start()``` calls ```main()```, and the program begins running. 

### Linker vs Loader

| Feature | Linker | Loader |
|:----------:|:-------------:|:------:|
| Runs when? | Before execution (compile/build time) | At program start (run time) |
| Purpose | Combines object files into executable | Loads executable in memory |
| Input | Object files, libraries | Executable file |
| Output | Final executable | Running process |
| Handles libraries | Yes (static/dynamic linking) | Yes (runtime symbol resolution) |
| Relocation | Performs major relocation | May perform final relocation |
| Where does it run? | User-level program | OS-level component |

### Dynamic Linking & Shared Libraries

- Pros : Smaller executables, reduced memory usage, easy library update, faster linking time.
- Cons : Library changes may break older applications, slight runtime overhead.

---

### Extra Points

#### Dynamic Loading vs Dynamic Linking

> Dynamic loading loads modules **on-demand** during execution. Dynamic linking links shared libraries **at runtime**, not compile time.

---
