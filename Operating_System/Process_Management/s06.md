---
title : Operating System Structure-3.6
description : chapter 3.6  of the <Operating System Concepts>
tags : [os, notes, ]
---

# Process Management

---

## 3.6 - IPC in Message-Passing Systems

> Message passing allows OS manages all communication without sharing memory.

### Basic Model

Two fundamental operations are ```send(msg)``` and ```receive(msg)```. 
Processes do not access each other's memory.

The OS handles message copying, queuing, protection, synchronization.

### Message Passing Model

- Direct communication -> Processes communicate using **names** of each other.

``` C
send(P1, msg);
receive(P2, msg);
```

- Indirect communication -> Processes communicate through **mailboxes** or **ports**.

``` C
send(mailbox, msg);
receive(mailbox, msg);
```

### Synchronous vs Asynchronous Communication

- Synchronous (Blocking) : Sender/receiver waits until message is received/arrived.
- Asynchronous : Sender does not wait. Receiver may get NULL if no messages. 

> Blocking send + blocking receive = tightly synchronized processes.

### Buffering

- Zero-capacity buffer (no queue) -> Sender must block until receiver is ready.
- Bounded buffer -> Sender blocks if buffer is full. Receiver blocks if empty.
- Unbounded buffer (infinite queue) -> Sender never blocks. Receiver blocks when empty.

### Message Passing in Local Systems

Even on the same machine, message passing is common. Ususally through pipes, named pipes, UNIX domain sockets, message queues.

### Message Passing in Distributed Systems

Message passing is the foundation of distributed OSes, since there is no shared memory. 
Communication must through network (TCP, UDP, RPC).

### Microkernel Dependency on Message Passing

Microkernel OSes rely heavily on message passing for deivce driver, file system server, networking server, IPC.

---

### Extra Points

#### Message passing is NOT only for networks

> Local IPC also uses message passing (pipes, message queues, sockets).

---
